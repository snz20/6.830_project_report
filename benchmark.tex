
\section{Benchmark}
\label{sec:bench}
In this section, we show the results of the benchmarks that we performed to assess the performance of our implementations in various settings. We also discuss the implications of the results that we found.
\subsection{Setup}
We ran the benchmark on PostgreSQL 9.1.9 and MADlib v3.0 on a single machine on a gigabit Ethernet cluster which runs Ubuntu 12.04 LTS and has 4GB RAM, a 10GB SATA HDD and a Core 2 Duo 2.4GHz CPU. 

To benchmark the performance of GP for Symbolic Regression we used a synthetic dataset containing 100,000 rows, 3 inputs and 1 output. The function we used to generate the data is $x_1*(x_2^2+x_3)$.

To benchmark the performance of AdaBoost, we used BUPA liver disorder dataset which contains blood test results of 345 male individuals. This dataset is available at \url{http://www.cs.huji.ac.il/~shais/datasets/ClassificationDatasets.html}. We also used a synthetic dataset which consisted of $240000\times11$ matrix where first 10 columns are real valued random numbers and the last column indicates the class.

Each run of our algorithms inside MADlib was cold start meaning that we cleared the caches and restarted the database service (PostgreSQL) for every run.
\subsection{Results}
Tables~\ref{tab:gp}, \ref{tab:adaBupa}, \ref{tab:adaSynth1} and \ref{tab:adaSynth2} summarize our benchmark results. Table~\ref{tab:gp} shows <Filled by Franck>. In Table~\ref{tab:adaBupa1}, we record the runtimes of row-by-row execution, batched execution and all-in-memory execution of AdaBoost inside MADlib. In Table~\ref{tab:adaBupa2}, we record the runtimes of the same algorithm when it reads data from a file or from PostgreSQL database outside MADlib or loads data into memory from Postgres residing inside MADlib. In all cases we varied the number of iterations parameter. Table~\ref{tab:adaSynth1} shows the runtimes and Table~\ref{tab:adaSynth2} shows the memory usage of row-by-row execution, batched execution and all-in-memory execution of AdaBoost when it is run on a synthetic dataset of varying size.   

\begin{table}[!htbp]
\centering
\begin{tabular}{lcc}
\end{tabular}
\caption{GP runtimes on synthetic dataset}
\label{tab:gp}
\end{table}

\begin{table}[!htbp]
\centering
\begin{tabular}{l|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{Number of Iterations} & \multicolumn{6}{|c|}{Runtimes (sec)}\\
\hline
& All-in-Memory & 2 Batches & 5 Batches & 10 Batches & 50 Batches & Row-by-Row\\
\hline
\end{tabular}
\caption{AdaBoost runtimes on BUPA liver disorder dataset (Row-by-Row vs. Batched vs. All-in-Memory execution).}
\label{tab:adaBupa1}
\end{table}

\begin{table}[!htbp]
\centering
\begin{tabular}{lcc}
\end{tabular}
\caption{AdaBoost runtimes on BUPA liver disorder dataset (Inside vs. Outside MADlib).}
\label{tab:adaBupa2}
\end{table}

\begin{table}[!htbp]
\centering
\begin{tabular}{lcc}
\end{tabular}
\caption{AdaBoost runtimes on synthetic dataset.}
\label{tab:adaSynth1}
\end{table}

\begin{table}[!htbp]
\centering
\begin{tabular}{lcc}
\end{tabular}
\caption{AdaBoost memory usage for synthetic dataset}
\label{tab:adaSynth2}
\end{table}

As we can see from the tables, runtime of both of the algorithms increase as we increase the number of independent variables. Running the algorithms using MADlib takes more time than bypassing MADlib altogether when data can be fit into memory. Running the algorithms using MADlib is advantageous when the dataset cannot be fit into memory. Batched execution is more efficient in terms of run time than row by row execution in terms of run time. It is more efficient than reading the whole dataset into memory in terms of memory usage.

\subsection{Analysis}
{\itshape Effect of varying independent variables on runtime.}

{\itshape Performance inside and outside MADlib}

{\itshape Performance of batched execution.}

{\itshape Effect of varying independent variables on memory usage.}
